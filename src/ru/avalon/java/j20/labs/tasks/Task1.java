package ru.avalon.java.j20.labs.tasks;

import ru.avalon.java.j20.labs.Task;

import java.io.*;

/**
 * Задание №1. Выполнено.
 * <p>
 * Тема: "Потоковый ввод-вывод. Чтение и запись данных в двоичном режиме".
 */
public class Task1 implements Task {

    /**
     * {@inheritDoc}
     */
    @Override
    public void run() throws IOException {
        File input = new File("assets/countries.txt"); // файл с исходными данными (входной файл)
        File output = new File("task1_countries_binary_mode_output.txt"); // файл, который может не существовать (сам создастся), и в который записывается результат чтения входного файла
        String text = read(input); // переменная, которая хранит результат чтения файла input в виде строки
        write(output, text); // запись результата чтения файла input (переменная text типа String) в файл output
    }

    /**
     * Выполняет чтение указанного файла в двоичном режиме. <n>
     *
     * Весь текст файла возвращается в виде одного экземпляра типа
     * {@link String}. <n>
     * На вход должны поступать данные из читаемого файла file (типа File),
     * приведенные к типу byte. Массив прочитанных элементов byte через буффер
     * записывается в массив результатов, который возвращается в качестве итога
     * выполнения метода ЧТЕНИЕ.
     *
     * @param file файл
     * @return содержимое файла в виде текста.
     * @throws IOException в случае ошибок ввода-вывода.
     */
    private String read(File file) throws IOException { // генерируются исключения
        // пытаемся отслеживать блок внутри try - то есть отслеживать проблемы при обращению к файлу file (могут быть проблемы - тогда генерируются исключения)
        try (InputStream stream = new FileInputStream(file)) { // открываем входной поток для файла?
            ByteArrayOutputStream arrayOutputStream = new ByteArrayOutputStream(); // массив типа byte, содержащий результат (стандартно на 32 байта выделено места, затем самостоятельно расширяется)
            byte[] buffer = new byte[10]; // массив буффер - для хранения переменных на каждом шаге, буффер на 10 элементов - за раз прочитает только 10 элементов или меньше
            int len; // количество прочитанных данных на каждом шаге чтения (после очередного переполнения буффера - новый шаг чтения)
            /**
             * Если читать нечего, то "stream.read(buffer))" вернет '-1'; если
             * нет данных, то вернет 0, данные есть - вернет количество
             * прочитанных данных <n>
             * В buffer вернем результат чтения. <n>
             * Пока есть что читать (количество прочитанных данных len > 0 -
             * записываем данные в arrayOutputStream (массив результатов).
             */
            while ((len = stream.read(buffer)) > 0) {  // читается (read) поток (stream) и сохраняется в buffer..возвращается количество элементов, которые были прочитаны
                arrayOutputStream.write(buffer, 0, len); // элементы из буфера (массива buffer) записываются в массив результатов
            }
            return arrayOutputStream.toString(); // массив с результатами переводим в строку и возвращаем в качестве результата
        }
    }

    /**
     * Выполняет запись текстовых данных в файл в двоичном режиме.<n>
     *
     * write(куда передаем, что передаем)
     *
     * @param file файл
     * @param text текст
     * @throws IOException в случае ошибок ввода-вывода.
     */
    private void write(File file, String text) throws IOException { // метод принимающий: 1. файл, в который будет происходить запись; 2. текст в виде строки - который хранит результат чтения файла input. Генерируются исключения.
        // пытаемся отслеживать блок внутри try - то есть отслеживать проблемы при обращению к файлу file (могут быть проблемы - тогда генерируются исключения)
        try (OutputStream stream = new FileOutputStream(file)) { // открываем выходной поток для файла?
            stream.write(text.getBytes()); // запись в поток текста, приведенного к типу Byte
        }
    }
    /**
     * TODO(Преподаватель): Не очень понимаю, как работает метод write. Мы
     * записываем в поток, с помощью него, текст переведенный в массив byte. Как
     * этот массив потом переводится в текст? То есть, в файл, который
     * происходит запись, записывается ведь текст, а не байты.
     */
}
